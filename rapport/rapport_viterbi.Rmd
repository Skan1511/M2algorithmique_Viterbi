---
title: "Algorithme de Viterbi — Rapport M2"
author: "Mohamed Skander Gharbi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Chargement des packages nécessaires
library(gtools)
library(ggplot2)
library(reshape2)
library(Biostrings)

# Chargement des fonctions définies dans tes scripts
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/naive_R/viterbi_naive.R")
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/viterbi_R/viterbi_algo.R")
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/naive_R/viterbi_naive_bio.R")
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/viterbi_R/viterbi_bio.R")
```

# Introduction

Dans ce projet, nous avons étudié et comparé deux approches de décodage de séquences dans les modèles de Markov cachés (HMM) :
- Une méthode **naïve** par force brute,
- L’**algorithme de Viterbi**, basé sur la programmation dynamique.

Nous avons tout d’abord testé nos algorithmes sur un exemple jouet (pluie/soleil), puis nous avons appliqué ces méthodes à un problème plus réaliste issu de la bioinformatique : **la détection de régions codantes dans une séquence d’ADN**.

# Problème étudié

Un HMM est défini par :
- Un ensemble d'états cachés : \( S = \{s_1, s_2, \dots, s_N\} \)
- Une séquence d'observations : \( O = \{o_1, o_2, \dots, o_T\} \)
- Une matrice de transition \( A \)
- Une matrice d'émission \( B \)
- Un vecteur de probabilités initiales \( \pi \)

L’objectif est de déterminer la séquence d’états cachés \( Q \) qui maximise \( P(Q|O) \).

# Méthodes sur un exemple jouet

## Méthode naïve

```{r}
# Exemple : exécution de la méthode naïve
sequence_naive <- trouver_sequence_naive(obs, states, pi, A, B)
```

## Algorithme de Viterbi

```{r}
# Exemple d'appel de Viterbi
sequence_viterbi <- viterbi(obs, states, pi, A, B)
```

# Benchmark expérimental

```{r}
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/benchmark_tailles.R")
df_long <- melt(df, id.vars = "Taille", variable.name = "Méthode", value.name = "Temps")

ggplot(df_long, aes(x = Taille, y = Temps, color = Méthode)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(
    title = "Temps d'exécution selon la taille de la séquence",
    x = "Taille de la séquence observée",
    y = "Temps (secondes)",
    color = "Méthode"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "bottom")
```

# Comparaison R vs C++

```{r benchmark_cpp_plot, echo=FALSE, message=FALSE, warning=FALSE}
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/benchmark_cpp.R")
```

# Application bioinformatique : Prédiction de régions codantes dans l’ADN

Dans cette seconde partie, nous simulons une séquence d’ADN avec des **régions codantes (C)** et **non codantes (N)**. Les matrices de transition et d’émission sont ensuite estimées à partir de cette séquence, puis utilisées pour appliquer les algorithmes.

## Génération de la séquence et des exons

```{r}
set.seed(42)
seq_length <- 500
bases <- c("A", "T", "C", "G")
seq <- paste(sample(bases, seq_length, replace = TRUE), collapse = "")
seq <- DNAString(seq)
states <- rep("N", seq_length)
cds_start <- sample(1:(seq_length - 100), 10, replace = TRUE)
cds_end <- cds_start + 100
for (i in 1:length(cds_start)) {
  states[cds_start[i]:cds_end[i]] <- "C"
}
```

## Estimation des matrices A et B

```{r}
count_CC <- count_CN <- count_NC <- count_NN <- 0
count_A_C <- count_T_C <- count_C_C <- count_G_C <- 0
count_A_N <- count_T_N <- count_C_N <- count_G_N <- 0

for (i in 2:seq_length) {
  if (states[i-1] == "C" && states[i] == "C") count_CC <- count_CC + 1
  else if (states[i-1] == "C") count_CN <- count_CN + 1
  else if (states[i] == "C") count_NC <- count_NC + 1
  else count_NN <- count_NN + 1

  base <- substring(as.character(seq), i, i)
  if (states[i] == "C") {
    if (base == "A") count_A_C <- count_A_C + 1
    if (base == "T") count_T_C <- count_T_C + 1
    if (base == "C") count_C_C <- count_C_C + 1
    if (base == "G") count_G_C <- count_G_C + 1
  } else {
    if (base == "A") count_A_N <- count_A_N + 1
    if (base == "T") count_T_N <- count_T_N + 1
    if (base == "C") count_C_N <- count_C_N + 1
    if (base == "G") count_G_N <- count_G_N + 1
  }
}

total_transitions <- count_CC + count_CN + count_NC + count_NN
A <- matrix(c(
  count_CC / total_transitions, count_CN / total_transitions,
  count_NC / total_transitions, count_NN / total_transitions
), byrow = TRUE, nrow = 2)
rownames(A) <- colnames(A) <- c("C", "N")

total_C <- count_A_C + count_T_C + count_C_C + count_G_C
total_N <- count_A_N + count_T_N + count_C_N + count_G_N

B <- matrix(c(
  count_A_C / total_C, count_T_C / total_C, count_C_C / total_C, count_G_C / total_C,
  count_A_N / total_N, count_T_N / total_N, count_C_N / total_N, count_G_N / total_N
), byrow = TRUE, nrow = 2)
rownames(B) <- c("C", "N")
colnames(B) <- c("A", "T", "C", "G")

print(A)
print(B)

pi <- c(0.5, 0.5)
states <- c("C", "N")
```

## Résultats des algorithmes

```{r}
# Séquence courte pour la méthode naïve
obs_small <- sample(1:4, 6, replace = TRUE)

# Méthode naïve sur obs_small
result_naif <- trouver_sequence_naive(obs_small, c("C", "N"), pi, A, B)


# Séquence plus longue
obs_long <- sample(1:4, 50, replace = TRUE)

# Méthode Viterbi (optimisée)
result_viterbi <- viterbi_bio_optimise(obs_long, pi, A, B)

cat("\nRésultats de l'algorithme Naïf (R):\n")
print(result_naif)

cat("\nRésultats de l'algorithme Viterbi (R):\n")
print(result_viterbi)
```

## Benchmark sur l'ADN

```{r}
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/benchmark_cpp_bio.R")
```

# Conclusion

Ce projet a permis de comparer deux approches d’inférence de séquences dans un modèle HMM. La version optimisée (Viterbi) montre une supériorité claire en performance.

L’application à une séquence d’ADN montre la capacité de cet algorithme à s’adapter à des cas réels, notamment dans le domaine de la bioinformatique (annotation de gènes).

Des pistes d’amélioration incluent :
- L’intégration de l’algorithme dans un pipeline bioinformatique complet
- La visualisation des séquences prédites
- Le traitement de séquences génomiques réelles
