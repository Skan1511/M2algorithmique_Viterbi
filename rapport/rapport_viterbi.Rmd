---
title: "Algorithme de Viterbi — Rapport M2"
author: "Mohamed Skander Gharbi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Installation du package depuis GitHub (à adapter si un jour tu publies)
devtools::install_github("Skan1511/viterbiM2")

# Chargement des packages nécessaires
library(gtools)
library(ggplot2)
library(reshape2)
library(Biostrings)

# Chargement des fonctions définies dans tes scripts
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/naive_R/viterbi_naive.R")
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/src/viterbi_R/viterbi_algo.R")
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/viterbi_brca1.R")
```

# Introduction

Dans ce projet, nous avons étudié et comparé deux approches de décodage de séquences dans les modèles de Markov cachés (HMM) :
- Une méthode **naïve** par force brute,
- L’**algorithme de Viterbi**, basé sur la programmation dynamique.

Nous avons tout d’abord testé nos algorithmes sur un exemple jouet (pluie/soleil), puis nous avons appliqué ces méthodes à un problème plus réaliste issu de la bioinformatique : **la détection de régions codantes dans une séquence d’ADN**.

# Problème étudié

Un HMM est défini par :
- Un ensemble d'états cachés : \( S = \{s_1, s_2, \dots, s_N\} \)
- Une séquence d'observations : \( O = \{o_1, o_2, \dots, o_T\} \)
- Une matrice de transition \( A \)
- Une matrice d'émission \( B \)
- Un vecteur de probabilités initiales \( \pi \)

L’objectif est de déterminer la séquence d’états cachés \( Q \) qui maximise \( P(Q|O) \).

# Méthodes

## Méthode naïve

```{r}
obs_small <- sample(1:4, 6, replace = TRUE)
result_naif <- trouver_sequence_naive_bio(obs_small, states, pi, A, B)
print(result_naif)
```

## Algorithme de Viterbi

```{r}
obs_long <- sample(1:4, 50, replace = TRUE)
result_viterbi <- viterbi(obs_long, states, pi, A, B)
print(result_viterbi)
```

# Benchmark expérimental

```{r}
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/benchmark_tailles.R")
df_long <- melt(df, id.vars = "Taille", variable.name = "Méthode", value.name = "Temps")

ggplot(df_long, aes(x = Taille, y = Temps, color = Méthode)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(
    title = "Temps d'exécution selon la taille de la séquence",
    x = "Taille de la séquence observée",
    y = "Temps (secondes)",
    color = "Méthode"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "bottom")
```

# Comparaison R vs C++

```{r benchmark_cpp_plot, message=FALSE, warning=FALSE}
source("C:/Users/gharb/Documents/M2algo_viterbi/M2algorithmique_Viterbi/simulations/benchmark_cpp_bio.R")
```

# Application bioinformatique : Prédiction de régions codantes dans l’ADN

Dans cette seconde partie, nous simulons une séquence d’ADN avec des **régions codantes (C)** et **non codantes (N)**. Les matrices de transition et d’émission sont ensuite estimées à partir de cette séquence, puis utilisées pour appliquer l’algorithme de Viterbi.

## Résultats des algorithmes

```{r}
cat("Résultat de l'algorithme Naïf (R):\n")
print(result_naif)

cat("\nRésultat de l'algorithme Viterbi (R):\n")
print(result_viterbi)
```

# Conclusion

Ce projet a permis de comparer deux approches d’inférence de séquences dans un modèle HMM. La version optimisée (Viterbi) montre une supériorité claire en performance.

L’application à une séquence d’ADN montre la capacité de cet algorithme à s’adapter à des cas réels, notamment dans le domaine de la bioinformatique (annotation de gènes).

Des pistes d’amélioration incluent :
- L’intégration de l’algorithme dans un pipeline bioinformatique complet
- La visualisation des séquences prédites
- Le traitement de séquences génomiques réelles
